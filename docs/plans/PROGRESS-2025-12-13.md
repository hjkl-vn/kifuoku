# Go Memory Replay Game - Progress Update
**Date:** 2025-12-13

## Current Status

### Completed Tasks (1-8)
- ‚úÖ Task 1: Project Setup and Dependencies
- ‚úÖ Task 2: Fengari Lua Bridge Setup
- ‚úÖ Task 3: SGF Parser Integration
- ‚úÖ Task 4: Lua Game State Core Structure
- ‚úÖ Task 5: Upload Phase UI Component
- ‚úÖ Task 6: Study Phase - Navigation Logic
- ‚úÖ Task 7: Replay Phase - Move Validation
- ‚úÖ Task 8: Hint System - Lua Logic

### In Progress
- üîÑ Task 9: Hint UI with Ghost Stones (not started yet)

### Remaining Tasks
- ‚è∏Ô∏è Task 10: Statistics Calculation
- ‚è∏Ô∏è Task 11: Stats Screen UI
- ‚è∏Ô∏è Task 12: Polish and Styling
- ‚è∏Ô∏è Task 13: README and Documentation

## Critical Bug Fixes Applied

### 1. Lua Indexing Bug (User-Identified)
**Issue:** Lua loops were using 0-based indexing (for y = 0, 18) instead of Lua's 1-based indexing.

**Fix Applied:**
- Changed all board initialization loops to `for y = 1, 19 do`
- Added coordinate conversion in `applyMove()`: `luaX = x + 1, luaY = y + 1`
- Fixed `prevMove()` and `startReplay()` to use 1-based indexing
- Added metatable for method inheritance in `GameState.new()`

**Files Modified:**
- `src/lua/game-state.lua`

### 2. Fengari Lua-JavaScript Interop Issues
**Issue:** Lua functions were returning function wrappers (`function r2()`) instead of actual return values.

**Root Cause:** `fengari.interop.tojs()` was creating proxy wrappers for Lua tables with metatables instead of converting them to plain JavaScript objects.

**Debug Process:**
1. Added debug logging to Lua code - confirmed Lua was returning correct tables
2. Identified that conversion was failing in JavaScript, not Lua
3. Discovered `fengari.interop.tojs()` doesn't properly convert tables with metatables

**Fix Applied:**
- Created custom `luaTableToJS()` function that manually iterates Lua tables using `lua_next`
- Implemented recursive conversion for nested tables
- Added array detection logic (sequential integer keys starting from 1)
- Converts Lua 1-based arrays to JavaScript 0-based arrays

**Files Modified:**
- `src/lib/lua-bridge.js`

### 3. Method Inheritance in Lua
**Issue:** `game:loadGame()` failed with "attempt to call a nil value (method 'loadGame')"

**Fix Applied:**
- Added `setmetatable(self, { __index = GameState })` in `GameState.new()`

**Files Modified:**
- `src/lua/game-state.lua`

### 4. JavaScript Interop Library Not Loaded
**Issue:** "js library not loaded into lua_State"

**Fix Applied:**
- Added `luaL_requiref()` call in `initLua()` to properly load Fengari's JS interop library

**Files Modified:**
- `src/lib/lua-bridge.js`

### 5. Variable Name Shadowing
**Issue:** `const initLua` variable shadowed the imported `initLua` function

**Fix Applied:**
- Renamed variable to `const initLuaCode`

**Files Modified:**
- `src/App.jsx`

## Current Implementation Details

### Lua Bridge (`src/lib/lua-bridge.js`)

The final working implementation uses a custom table conversion function:

```javascript
function luaTableToJS(L, index) {
  const tempResult = {}
  const keys = []

  // Adjust index to absolute position
  if (index < 0) {
    index = fengari.lua.lua_gettop(L) + index + 1
  }

  // Iterate table with lua_next
  fengari.lua.lua_pushnil(L)
  while (fengari.lua.lua_next(L, index) !== 0) {
    const key = fengari.interop.tojs(L, -2)
    keys.push(key)

    // Recursively convert nested tables
    const valueType = fengari.lua.lua_type(L, -1)
    let value
    if (valueType === fengari.lua.LUA_TTABLE) {
      value = luaTableToJS(L, -1)
    } else {
      value = fengari.interop.tojs(L, -1)
    }

    tempResult[key] = value
    fengari.lua.lua_pop(L, 1)
  }

  // Detect arrays (sequential integer keys from 1)
  const isArray = keys.length > 0 && keys.every((k, i) => k === i + 1)

  if (isArray) {
    // Convert to 0-based JavaScript array
    const arr = []
    for (let i = 1; i <= keys.length; i++) {
      arr.push(tempResult[i])
    }
    return arr
  } else {
    return tempResult
  }
}
```

### Hint Generation Logic (`src/lua/game-state.lua`)

Added three new functions:

1. **`generateHints()`** - Generates 1 correct + 3 random nearby positions
2. **`isValidHintPosition()`** - Validates hint positions (on board, empty, unique)
3. **`selectHint()`** - Handles hint selection from player

**Key Features:**
- Proper coordinate conversion (0-based JS ‚Üî 1-based Lua)
- Random offset generation (-4 to +4 from correct position)
- Validation against occupied positions
- Returns `nextColor` for proper stone rendering

## Testing Status

### Last Known State
**Console Output (Latest Test):**
```
DEBUG: GameState type: table
DEBUG: GameState.new type: function
DEBUG: game type after new(): table
DEBUG: game.loadGame type: function
Lua game engine initialized
Parsed moves: 147
initGame result: Object { success: true, phase: "study", totalMoves: 147 }
getGameState result: Object { phase: "study", studyPosition: 0, ..., boardState: {‚Ä¶} }
```

**Current Issue:**
```
TypeError: can't access property "length", signMap[0] is undefined
```

**Analysis:**
- Lua functions now successfully return JavaScript objects
- `boardState` is being converted from Lua table to JavaScript object
- Need to verify array conversion is working (Lua 1-based ‚Üí JS 0-based)
- Shudan Goban expects `signMap` to be a proper array

**Next Debug Step:**
Reload page and inspect `gameState.boardState` in console to verify it's a proper 2D array.

## Files Modified This Session

### Lua Files
- `src/lua/game-state.lua` - Added hint system, fixed indexing
- `src/lua/init.lua` - Added debug logging, `selectHint` export

### JavaScript Files
- `src/lib/lua-bridge.js` - Complete rewrite of table conversion logic
- `src/App.jsx` - Variable rename (initLua ‚Üí initLuaCode)

### Configuration Files
- `vite.config.js` - Fixed module resolution (path.resolve)

## Next Session TODO

1. **Verify Array Conversion** - Test that boardState is properly converted to 2D array
2. **Remove Debug Logging** - Clean up console.log statements from init.lua
3. **Complete Task 9** - Implement HintOverlay UI component
4. **Test Study Phase** - Verify navigation works (prev/next buttons)
5. **Test Replay Phase** - Verify move validation and hint display
6. **Continue with Tasks 10-13**

## Architecture Notes

### Coordinate Systems
- **JavaScript/SGF:** 0-based indexing (0-18)
- **Lua:** 1-based indexing (1-19)
- **Conversion Points:**
  - `applyMove()`: Converts JS coords to Lua coords
  - `luaTableToJS()`: Converts Lua arrays to JS arrays

### Data Flow
```
User uploads SGF
  ‚Üì
parseSGFToMoves() ‚Üí 0-based coords
  ‚Üì
callLuaFunction('initGame', moves)
  ‚Üì
Lua receives moves (0-based, treated as userdata)
  ‚Üì
applyMove() converts to 1-based for boardState
  ‚Üì
getGameState() returns Lua table (1-based arrays)
  ‚Üì
luaTableToJS() converts to JS arrays (0-based)
  ‚Üì
Shudan renders with 0-based arrays
```

## Known Working Features

- ‚úÖ SGF file upload and parsing
- ‚úÖ Lua VM initialization with JS interop
- ‚úÖ Game state creation and initialization
- ‚úÖ Move data passing from JS to Lua
- ‚úÖ Table/array conversion from Lua to JS
- ‚úÖ Hint generation logic in Lua
- ‚ö†Ô∏è Board state rendering (in progress)

## Lessons Learned

1. **Fengari Interop Limitations:** `fengari.interop.tojs()` doesn't handle tables with metatables well - manual conversion required
2. **Lua Indexing:** Critical to maintain 1-based indexing in Lua, convert only at boundaries
3. **Stack Management:** Lua stack indices must be converted to absolute when nesting calls
4. **Debug Early:** Adding Lua-side debug logging helped identify the JS interop issue quickly
5. **Array Detection:** Need explicit logic to distinguish Lua arrays from Lua tables with string keys
